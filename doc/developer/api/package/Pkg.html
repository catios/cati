<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>package.Pkg API documentation</title>
<meta name="description" content="Package model" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>package.Pkg</code></h1>
</header>
<section id="section-intro">
<p>Package model</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Pkg.py
#
# the cati project
# Copyright 2020 parsa mpsh &lt;parsampsh@gmail.com&gt;
#
# This file is part of cati.
#
# cati is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cati is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cati.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
##################################################

&#39;&#39;&#39; Package model &#39;&#39;&#39;

import os
import json
from frontend import Env
from frontend.SysArch import sys_arch
from package.exceptions import CannotReadFileException
from packaging import version

class Pkg:
    &#39;&#39;&#39; Package model &#39;&#39;&#39;

    def __init__(self, data: dict):
        self.data = data
        try:
            self.data[&#39;repo&#39;]
        except:
            self.data[&#39;repo&#39;] = &#39;Local&#39;

    def installed(self):
        &#39;&#39;&#39; Checks current package is installed &#39;&#39;&#39;
        if not Pkg.is_installed(self.data[&#39;name&#39;]):
            return False

        return Pkg.installed_version(self.data[&#39;name&#39;])

    def get_depends(self):
        &#39;&#39;&#39; Returns package dependencies list &#39;&#39;&#39;
        try:
            return self.data[&#39;depends&#39;]
        except:
            return []

    def get_conflicts(self):
        &#39;&#39;&#39; Returns package conflicts list &#39;&#39;&#39;
        try:
            return self.data[&#39;conflicts&#39;]
        except:
            return []

    def get_reverse_depends(self) -&gt; list:
        &#39;&#39;&#39; Returns list of packages has dependency to this package &#39;&#39;&#39;
        reverse_depends = []
        for pkg in self.all_list()[&#39;list&#39;]:
            for dep in pkg.get_depends():
                if dep.strip().split(&#39; &#39;)[0] == self.data[&#39;name&#39;]:
                    reverse_depends.append(pkg)
        return reverse_depends

    @staticmethod
    def load_last(pkg_name: str):
        &#39;&#39;&#39; Load last version of package by name &#39;&#39;&#39;
        pkgs_list = Pkg.all_list()
        for item in pkgs_list[&#39;list&#39;]:
            if item.data[&#39;name&#39;] == pkg_name:
                return item
        return False

    @staticmethod
    def is_installed(package_name: str):
        &#39;&#39;&#39; Gets a package name and checks is installed or not &#39;&#39;&#39;
        try:
            assert os.path.isdir(Env.installed_lists(&#39;/&#39; + package_name))
            assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;))
            assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/files&#39;))
            # TODO : check more files

            return True
        except:
            return False

    @staticmethod
    def is_installed_manual(package_name):
        if not Pkg.is_installed(package_name):
            return False
        return os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/manual&#39;))

    @staticmethod
    def installed_version(package_name: str):
        &#39;&#39;&#39; Gets name of package and returns installed version of that &#39;&#39;&#39;
        try:
            f = open(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;), &#39;r&#39;)
            version = f.read()
            f.close()
        except:
            raise CannotReadFileException(&#39;cannot read file &#34;&#39; + Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;) + &#39;&#34;&#39;)
        return version

    @staticmethod
    def installed_list():
        &#39;&#39;&#39; Returns list of only installed packages &#39;&#39;&#39;
        all_packages = Pkg.all_list()
        installed_packages = {
            &#39;errors&#39;: all_packages[&#39;errors&#39;],
            &#39;list&#39;: [],
        }
        for pkg in all_packages[&#39;list&#39;]:
            if pkg.installed():
                installed_packages[&#39;list&#39;].append(pkg)

        return installed_packages

    @staticmethod
    def all_list():
        &#39;&#39;&#39; Returns list of packages &#39;&#39;&#39;

        errors = []
        packages = []

        for item in os.listdir(Env.packages_lists()):
            if os.path.isfile(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;)):
                f_index = open(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;), &#39;r&#39;)
                try:
                    index_content = f_index.read()
                    try:
                        index_json = json.loads(index_content)
                        try:
                            pkg = Pkg.load_from_index(index_json, item)
                            packages.append(pkg)
                        except:
                            errors.append(&#39;faild to load package &#34;&#39; + item + &#39;&#34;&#39;)
                    except:
                        errors.append(&#39;invalid json content in &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
                except:
                    errors.append(&#39;cannot read file &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
            else:
                errors.append(f&#39;package &#34;{item}&#34; has not index file in lists ({Env.packages_lists(&#34;/&#34; + item + &#34;/index&#34;)} not found)&#39;)

        return {&#39;list&#39;: packages, &#39;errors&#39;: errors}

    @staticmethod
    def compare_version(a, b):
        &#39;&#39;&#39;
        Compares two versions
        if 1 is returned means a is upper than b
        if 0 is returned means a equals b
        if -1 is returned means a is less than b
        &#39;&#39;&#39;
        a = version.parse(a)
        b = version.parse(b)

        if a &gt; b:
            return 1

        if a == b:
            return 0

        if a &lt; b:
            return -1

    @staticmethod
    def get_last_version(versions: list):
        &#39;&#39;&#39; Gets a list from versions and returns latest version in that list &#39;&#39;&#39;
        max_ver = &#39;&#39;
        for version in versions:
            if Pkg.compare_version(version, max_ver) == 1:
                max_ver = version

        return max_ver

    @staticmethod
    def load_from_index(index_json: dict, package_name: str):
        &#39;&#39;&#39; Loads package data from index file &#39;&#39;&#39;
        try:
            arch = sys_arch()
            versions = index_json[arch]
        except:
            try:
                arch = &#39;all&#39;
                versions = index_json[arch]
            except:
                arch = list(index_json.keys())[0]
                versions = index_json[arch]

        # load latest version
        ver = Pkg.get_last_version(versions)

        f = open(Env.packages_lists(&#39;/&#39; + package_name + &#39;/&#39; + ver + &#39;-&#39; + arch), &#39;r&#39;)
        content = f.read()
        f.close()

        content_json = json.loads(content)

        return Pkg(content_json)

    def check_state(query_string: str) -&gt; bool:
        &#39;&#39;&#39;
        Checks package state by query string

        For examples:
        &#34;somepackage &gt;= 1.5&#34;
        &#34;somepackage&#34;
        &#34;somepackage = 2.0&#34;
        &#34;somepackage &lt; 1.7&#34;
        &#34;pkga | pkgb &gt;= 1.0&#34;
        &#34;pkga | pkgb | pkgc&#34;
        &#34;pkga | pkgb &amp; pkgc = 1.0&#34;
        &#39;&#39;&#39;

        # parse query string
        parts = query_string.strip().split(&#39;|&#39;)
        orig_parts = []
        for part in parts:
            tmp = part.strip().split(&#39;&amp;&#39;)
            orig_parts.append(tmp)
        
        # parse once query
        i = 0
        while i &lt; len(orig_parts):
            j = 0
            while j &lt; len(orig_parts[i]):
                orig_parts[i][j] = orig_parts[i][j].strip()
                spliter = None
                if &#39;&gt;=&#39; in orig_parts[i][j]:
                    spliter = &#39;&gt;=&#39;
                elif &#39;&gt;=&#39; in orig_parts[i][j]:
                    spliter = &#39;&lt;=&#39;
                elif &#39;&gt;&#39; in orig_parts[i][j]:
                    spliter = &#39;&gt;&#39;
                elif &#39;&lt;&#39; in orig_parts[i][j]:
                    spliter = &#39;&lt;&#39;
                elif &#39;=&#39; in orig_parts[i][j]:
                    spliter = &#39;=&#39;
                if spliter != None:
                    orig_parts[i][j] = orig_parts[i][j].split(spliter)
                    orig_parts[i][j].insert(1, spliter)
                else:
                    orig_parts[i][j] = [orig_parts[i][j]]
                z = 0
                while z &lt; len(orig_parts[i][j]):
                    orig_parts[i][j][z] = orig_parts[i][j][z].strip()
                    z += 1
                j += 1
            i += 1

        # check query
        for tmp in orig_parts:
            ands_ok = True
            for p in tmp:
                if len(p) == 1:
                    if not Pkg.is_installed(p[0]):
                        ands_ok = False
                elif len(p) == 3:
                    if not Pkg.is_installed(p[0]):
                        ands_ok = False
                    else:
                        a_ver = Pkg.installed_version(p[0])
                        b_ver = p[2]
                        if p[1] == &#39;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        elif p[1] == &#39;&gt;&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 1:
                                ands_ok = False
                        elif p[1] == &#39;&lt;&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != -1:
                                ands_ok = False
                        elif p[1] == &#39;&lt;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != -1 and Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        elif p[1] == &#39;&gt;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 1 and Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        else:
                            ands_ok = False
            if ands_ok:
                return True

        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="package.Pkg.Pkg"><code class="flex name class">
<span>class <span class="ident">Pkg</span></span>
<span>(</span><span>data: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Package model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pkg:
    &#39;&#39;&#39; Package model &#39;&#39;&#39;

    def __init__(self, data: dict):
        self.data = data
        try:
            self.data[&#39;repo&#39;]
        except:
            self.data[&#39;repo&#39;] = &#39;Local&#39;

    def installed(self):
        &#39;&#39;&#39; Checks current package is installed &#39;&#39;&#39;
        if not Pkg.is_installed(self.data[&#39;name&#39;]):
            return False

        return Pkg.installed_version(self.data[&#39;name&#39;])

    def get_depends(self):
        &#39;&#39;&#39; Returns package dependencies list &#39;&#39;&#39;
        try:
            return self.data[&#39;depends&#39;]
        except:
            return []

    def get_conflicts(self):
        &#39;&#39;&#39; Returns package conflicts list &#39;&#39;&#39;
        try:
            return self.data[&#39;conflicts&#39;]
        except:
            return []

    def get_reverse_depends(self) -&gt; list:
        &#39;&#39;&#39; Returns list of packages has dependency to this package &#39;&#39;&#39;
        reverse_depends = []
        for pkg in self.all_list()[&#39;list&#39;]:
            for dep in pkg.get_depends():
                if dep.strip().split(&#39; &#39;)[0] == self.data[&#39;name&#39;]:
                    reverse_depends.append(pkg)
        return reverse_depends

    @staticmethod
    def load_last(pkg_name: str):
        &#39;&#39;&#39; Load last version of package by name &#39;&#39;&#39;
        pkgs_list = Pkg.all_list()
        for item in pkgs_list[&#39;list&#39;]:
            if item.data[&#39;name&#39;] == pkg_name:
                return item
        return False

    @staticmethod
    def is_installed(package_name: str):
        &#39;&#39;&#39; Gets a package name and checks is installed or not &#39;&#39;&#39;
        try:
            assert os.path.isdir(Env.installed_lists(&#39;/&#39; + package_name))
            assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;))
            assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/files&#39;))
            # TODO : check more files

            return True
        except:
            return False

    @staticmethod
    def is_installed_manual(package_name):
        if not Pkg.is_installed(package_name):
            return False
        return os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/manual&#39;))

    @staticmethod
    def installed_version(package_name: str):
        &#39;&#39;&#39; Gets name of package and returns installed version of that &#39;&#39;&#39;
        try:
            f = open(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;), &#39;r&#39;)
            version = f.read()
            f.close()
        except:
            raise CannotReadFileException(&#39;cannot read file &#34;&#39; + Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;) + &#39;&#34;&#39;)
        return version

    @staticmethod
    def installed_list():
        &#39;&#39;&#39; Returns list of only installed packages &#39;&#39;&#39;
        all_packages = Pkg.all_list()
        installed_packages = {
            &#39;errors&#39;: all_packages[&#39;errors&#39;],
            &#39;list&#39;: [],
        }
        for pkg in all_packages[&#39;list&#39;]:
            if pkg.installed():
                installed_packages[&#39;list&#39;].append(pkg)

        return installed_packages

    @staticmethod
    def all_list():
        &#39;&#39;&#39; Returns list of packages &#39;&#39;&#39;

        errors = []
        packages = []

        for item in os.listdir(Env.packages_lists()):
            if os.path.isfile(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;)):
                f_index = open(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;), &#39;r&#39;)
                try:
                    index_content = f_index.read()
                    try:
                        index_json = json.loads(index_content)
                        try:
                            pkg = Pkg.load_from_index(index_json, item)
                            packages.append(pkg)
                        except:
                            errors.append(&#39;faild to load package &#34;&#39; + item + &#39;&#34;&#39;)
                    except:
                        errors.append(&#39;invalid json content in &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
                except:
                    errors.append(&#39;cannot read file &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
            else:
                errors.append(f&#39;package &#34;{item}&#34; has not index file in lists ({Env.packages_lists(&#34;/&#34; + item + &#34;/index&#34;)} not found)&#39;)

        return {&#39;list&#39;: packages, &#39;errors&#39;: errors}

    @staticmethod
    def compare_version(a, b):
        &#39;&#39;&#39;
        Compares two versions
        if 1 is returned means a is upper than b
        if 0 is returned means a equals b
        if -1 is returned means a is less than b
        &#39;&#39;&#39;
        a = version.parse(a)
        b = version.parse(b)

        if a &gt; b:
            return 1

        if a == b:
            return 0

        if a &lt; b:
            return -1

    @staticmethod
    def get_last_version(versions: list):
        &#39;&#39;&#39; Gets a list from versions and returns latest version in that list &#39;&#39;&#39;
        max_ver = &#39;&#39;
        for version in versions:
            if Pkg.compare_version(version, max_ver) == 1:
                max_ver = version

        return max_ver

    @staticmethod
    def load_from_index(index_json: dict, package_name: str):
        &#39;&#39;&#39; Loads package data from index file &#39;&#39;&#39;
        try:
            arch = sys_arch()
            versions = index_json[arch]
        except:
            try:
                arch = &#39;all&#39;
                versions = index_json[arch]
            except:
                arch = list(index_json.keys())[0]
                versions = index_json[arch]

        # load latest version
        ver = Pkg.get_last_version(versions)

        f = open(Env.packages_lists(&#39;/&#39; + package_name + &#39;/&#39; + ver + &#39;-&#39; + arch), &#39;r&#39;)
        content = f.read()
        f.close()

        content_json = json.loads(content)

        return Pkg(content_json)

    def check_state(query_string: str) -&gt; bool:
        &#39;&#39;&#39;
        Checks package state by query string

        For examples:
        &#34;somepackage &gt;= 1.5&#34;
        &#34;somepackage&#34;
        &#34;somepackage = 2.0&#34;
        &#34;somepackage &lt; 1.7&#34;
        &#34;pkga | pkgb &gt;= 1.0&#34;
        &#34;pkga | pkgb | pkgc&#34;
        &#34;pkga | pkgb &amp; pkgc = 1.0&#34;
        &#39;&#39;&#39;

        # parse query string
        parts = query_string.strip().split(&#39;|&#39;)
        orig_parts = []
        for part in parts:
            tmp = part.strip().split(&#39;&amp;&#39;)
            orig_parts.append(tmp)
        
        # parse once query
        i = 0
        while i &lt; len(orig_parts):
            j = 0
            while j &lt; len(orig_parts[i]):
                orig_parts[i][j] = orig_parts[i][j].strip()
                spliter = None
                if &#39;&gt;=&#39; in orig_parts[i][j]:
                    spliter = &#39;&gt;=&#39;
                elif &#39;&gt;=&#39; in orig_parts[i][j]:
                    spliter = &#39;&lt;=&#39;
                elif &#39;&gt;&#39; in orig_parts[i][j]:
                    spliter = &#39;&gt;&#39;
                elif &#39;&lt;&#39; in orig_parts[i][j]:
                    spliter = &#39;&lt;&#39;
                elif &#39;=&#39; in orig_parts[i][j]:
                    spliter = &#39;=&#39;
                if spliter != None:
                    orig_parts[i][j] = orig_parts[i][j].split(spliter)
                    orig_parts[i][j].insert(1, spliter)
                else:
                    orig_parts[i][j] = [orig_parts[i][j]]
                z = 0
                while z &lt; len(orig_parts[i][j]):
                    orig_parts[i][j][z] = orig_parts[i][j][z].strip()
                    z += 1
                j += 1
            i += 1

        # check query
        for tmp in orig_parts:
            ands_ok = True
            for p in tmp:
                if len(p) == 1:
                    if not Pkg.is_installed(p[0]):
                        ands_ok = False
                elif len(p) == 3:
                    if not Pkg.is_installed(p[0]):
                        ands_ok = False
                    else:
                        a_ver = Pkg.installed_version(p[0])
                        b_ver = p[2]
                        if p[1] == &#39;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        elif p[1] == &#39;&gt;&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 1:
                                ands_ok = False
                        elif p[1] == &#39;&lt;&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != -1:
                                ands_ok = False
                        elif p[1] == &#39;&lt;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != -1 and Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        elif p[1] == &#39;&gt;=&#39;:
                            if Pkg.compare_version(a_ver, b_ver) != 1 and Pkg.compare_version(a_ver, b_ver) != 0:
                                ands_ok = False
                        else:
                            ands_ok = False
            if ands_ok:
                return True

        return False</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="package.Pkg.Pkg.all_list"><code class="name flex">
<span>def <span class="ident">all_list</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of packages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def all_list():
    &#39;&#39;&#39; Returns list of packages &#39;&#39;&#39;

    errors = []
    packages = []

    for item in os.listdir(Env.packages_lists()):
        if os.path.isfile(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;)):
            f_index = open(Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;), &#39;r&#39;)
            try:
                index_content = f_index.read()
                try:
                    index_json = json.loads(index_content)
                    try:
                        pkg = Pkg.load_from_index(index_json, item)
                        packages.append(pkg)
                    except:
                        errors.append(&#39;faild to load package &#34;&#39; + item + &#39;&#34;&#39;)
                except:
                    errors.append(&#39;invalid json content in &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
            except:
                errors.append(&#39;cannot read file &#34;&#39; + Env.packages_lists(&#39;/&#39; + item + &#39;/index&#39;) + &#39;&#34;&#39;)
        else:
            errors.append(f&#39;package &#34;{item}&#34; has not index file in lists ({Env.packages_lists(&#34;/&#34; + item + &#34;/index&#34;)} not found)&#39;)

    return {&#39;list&#39;: packages, &#39;errors&#39;: errors}</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.compare_version"><code class="name flex">
<span>def <span class="ident">compare_version</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Compares two versions
if 1 is returned means a is upper than b
if 0 is returned means a equals b
if -1 is returned means a is less than b</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compare_version(a, b):
    &#39;&#39;&#39;
    Compares two versions
    if 1 is returned means a is upper than b
    if 0 is returned means a equals b
    if -1 is returned means a is less than b
    &#39;&#39;&#39;
    a = version.parse(a)
    b = version.parse(b)

    if a &gt; b:
        return 1

    if a == b:
        return 0

    if a &lt; b:
        return -1</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.get_last_version"><code class="name flex">
<span>def <span class="ident">get_last_version</span></span>(<span>versions: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list from versions and returns latest version in that list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_last_version(versions: list):
    &#39;&#39;&#39; Gets a list from versions and returns latest version in that list &#39;&#39;&#39;
    max_ver = &#39;&#39;
    for version in versions:
        if Pkg.compare_version(version, max_ver) == 1:
            max_ver = version

    return max_ver</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.installed_list"><code class="name flex">
<span>def <span class="ident">installed_list</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of only installed packages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def installed_list():
    &#39;&#39;&#39; Returns list of only installed packages &#39;&#39;&#39;
    all_packages = Pkg.all_list()
    installed_packages = {
        &#39;errors&#39;: all_packages[&#39;errors&#39;],
        &#39;list&#39;: [],
    }
    for pkg in all_packages[&#39;list&#39;]:
        if pkg.installed():
            installed_packages[&#39;list&#39;].append(pkg)

    return installed_packages</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.installed_version"><code class="name flex">
<span>def <span class="ident">installed_version</span></span>(<span>package_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets name of package and returns installed version of that</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def installed_version(package_name: str):
    &#39;&#39;&#39; Gets name of package and returns installed version of that &#39;&#39;&#39;
    try:
        f = open(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;), &#39;r&#39;)
        version = f.read()
        f.close()
    except:
        raise CannotReadFileException(&#39;cannot read file &#34;&#39; + Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;) + &#39;&#34;&#39;)
    return version</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.is_installed"><code class="name flex">
<span>def <span class="ident">is_installed</span></span>(<span>package_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a package name and checks is installed or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_installed(package_name: str):
    &#39;&#39;&#39; Gets a package name and checks is installed or not &#39;&#39;&#39;
    try:
        assert os.path.isdir(Env.installed_lists(&#39;/&#39; + package_name))
        assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/ver&#39;))
        assert os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/files&#39;))
        # TODO : check more files

        return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.is_installed_manual"><code class="name flex">
<span>def <span class="ident">is_installed_manual</span></span>(<span>package_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_installed_manual(package_name):
    if not Pkg.is_installed(package_name):
        return False
    return os.path.isfile(Env.installed_lists(&#39;/&#39; + package_name + &#39;/manual&#39;))</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.load_from_index"><code class="name flex">
<span>def <span class="ident">load_from_index</span></span>(<span>index_json: dict, package_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads package data from index file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_index(index_json: dict, package_name: str):
    &#39;&#39;&#39; Loads package data from index file &#39;&#39;&#39;
    try:
        arch = sys_arch()
        versions = index_json[arch]
    except:
        try:
            arch = &#39;all&#39;
            versions = index_json[arch]
        except:
            arch = list(index_json.keys())[0]
            versions = index_json[arch]

    # load latest version
    ver = Pkg.get_last_version(versions)

    f = open(Env.packages_lists(&#39;/&#39; + package_name + &#39;/&#39; + ver + &#39;-&#39; + arch), &#39;r&#39;)
    content = f.read()
    f.close()

    content_json = json.loads(content)

    return Pkg(content_json)</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.load_last"><code class="name flex">
<span>def <span class="ident">load_last</span></span>(<span>pkg_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load last version of package by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_last(pkg_name: str):
    &#39;&#39;&#39; Load last version of package by name &#39;&#39;&#39;
    pkgs_list = Pkg.all_list()
    for item in pkgs_list[&#39;list&#39;]:
        if item.data[&#39;name&#39;] == pkg_name:
            return item
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="package.Pkg.Pkg.check_state"><code class="name flex">
<span>def <span class="ident">check_state</span></span>(<span>query_string: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks package state by query string</p>
<p>For examples:
"somepackage &gt;= 1.5"
"somepackage"
"somepackage = 2.0"
"somepackage &lt; 1.7"
"pkga | pkgb &gt;= 1.0"
"pkga | pkgb | pkgc"
"pkga | pkgb &amp; pkgc = 1.0"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_state(query_string: str) -&gt; bool:
    &#39;&#39;&#39;
    Checks package state by query string

    For examples:
    &#34;somepackage &gt;= 1.5&#34;
    &#34;somepackage&#34;
    &#34;somepackage = 2.0&#34;
    &#34;somepackage &lt; 1.7&#34;
    &#34;pkga | pkgb &gt;= 1.0&#34;
    &#34;pkga | pkgb | pkgc&#34;
    &#34;pkga | pkgb &amp; pkgc = 1.0&#34;
    &#39;&#39;&#39;

    # parse query string
    parts = query_string.strip().split(&#39;|&#39;)
    orig_parts = []
    for part in parts:
        tmp = part.strip().split(&#39;&amp;&#39;)
        orig_parts.append(tmp)
    
    # parse once query
    i = 0
    while i &lt; len(orig_parts):
        j = 0
        while j &lt; len(orig_parts[i]):
            orig_parts[i][j] = orig_parts[i][j].strip()
            spliter = None
            if &#39;&gt;=&#39; in orig_parts[i][j]:
                spliter = &#39;&gt;=&#39;
            elif &#39;&gt;=&#39; in orig_parts[i][j]:
                spliter = &#39;&lt;=&#39;
            elif &#39;&gt;&#39; in orig_parts[i][j]:
                spliter = &#39;&gt;&#39;
            elif &#39;&lt;&#39; in orig_parts[i][j]:
                spliter = &#39;&lt;&#39;
            elif &#39;=&#39; in orig_parts[i][j]:
                spliter = &#39;=&#39;
            if spliter != None:
                orig_parts[i][j] = orig_parts[i][j].split(spliter)
                orig_parts[i][j].insert(1, spliter)
            else:
                orig_parts[i][j] = [orig_parts[i][j]]
            z = 0
            while z &lt; len(orig_parts[i][j]):
                orig_parts[i][j][z] = orig_parts[i][j][z].strip()
                z += 1
            j += 1
        i += 1

    # check query
    for tmp in orig_parts:
        ands_ok = True
        for p in tmp:
            if len(p) == 1:
                if not Pkg.is_installed(p[0]):
                    ands_ok = False
            elif len(p) == 3:
                if not Pkg.is_installed(p[0]):
                    ands_ok = False
                else:
                    a_ver = Pkg.installed_version(p[0])
                    b_ver = p[2]
                    if p[1] == &#39;=&#39;:
                        if Pkg.compare_version(a_ver, b_ver) != 0:
                            ands_ok = False
                    elif p[1] == &#39;&gt;&#39;:
                        if Pkg.compare_version(a_ver, b_ver) != 1:
                            ands_ok = False
                    elif p[1] == &#39;&lt;&#39;:
                        if Pkg.compare_version(a_ver, b_ver) != -1:
                            ands_ok = False
                    elif p[1] == &#39;&lt;=&#39;:
                        if Pkg.compare_version(a_ver, b_ver) != -1 and Pkg.compare_version(a_ver, b_ver) != 0:
                            ands_ok = False
                    elif p[1] == &#39;&gt;=&#39;:
                        if Pkg.compare_version(a_ver, b_ver) != 1 and Pkg.compare_version(a_ver, b_ver) != 0:
                            ands_ok = False
                    else:
                        ands_ok = False
        if ands_ok:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.get_conflicts"><code class="name flex">
<span>def <span class="ident">get_conflicts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns package conflicts list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conflicts(self):
    &#39;&#39;&#39; Returns package conflicts list &#39;&#39;&#39;
    try:
        return self.data[&#39;conflicts&#39;]
    except:
        return []</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.get_depends"><code class="name flex">
<span>def <span class="ident">get_depends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns package dependencies list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_depends(self):
    &#39;&#39;&#39; Returns package dependencies list &#39;&#39;&#39;
    try:
        return self.data[&#39;depends&#39;]
    except:
        return []</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.get_reverse_depends"><code class="name flex">
<span>def <span class="ident">get_reverse_depends</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of packages has dependency to this package</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reverse_depends(self) -&gt; list:
    &#39;&#39;&#39; Returns list of packages has dependency to this package &#39;&#39;&#39;
    reverse_depends = []
    for pkg in self.all_list()[&#39;list&#39;]:
        for dep in pkg.get_depends():
            if dep.strip().split(&#39; &#39;)[0] == self.data[&#39;name&#39;]:
                reverse_depends.append(pkg)
    return reverse_depends</code></pre>
</details>
</dd>
<dt id="package.Pkg.Pkg.installed"><code class="name flex">
<span>def <span class="ident">installed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks current package is installed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def installed(self):
    &#39;&#39;&#39; Checks current package is installed &#39;&#39;&#39;
    if not Pkg.is_installed(self.data[&#39;name&#39;]):
        return False

    return Pkg.installed_version(self.data[&#39;name&#39;])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="package" href="index.html">package</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="package.Pkg.Pkg" href="#package.Pkg.Pkg">Pkg</a></code></h4>
<ul class="two-column">
<li><code><a title="package.Pkg.Pkg.all_list" href="#package.Pkg.Pkg.all_list">all_list</a></code></li>
<li><code><a title="package.Pkg.Pkg.check_state" href="#package.Pkg.Pkg.check_state">check_state</a></code></li>
<li><code><a title="package.Pkg.Pkg.compare_version" href="#package.Pkg.Pkg.compare_version">compare_version</a></code></li>
<li><code><a title="package.Pkg.Pkg.get_conflicts" href="#package.Pkg.Pkg.get_conflicts">get_conflicts</a></code></li>
<li><code><a title="package.Pkg.Pkg.get_depends" href="#package.Pkg.Pkg.get_depends">get_depends</a></code></li>
<li><code><a title="package.Pkg.Pkg.get_last_version" href="#package.Pkg.Pkg.get_last_version">get_last_version</a></code></li>
<li><code><a title="package.Pkg.Pkg.get_reverse_depends" href="#package.Pkg.Pkg.get_reverse_depends">get_reverse_depends</a></code></li>
<li><code><a title="package.Pkg.Pkg.installed" href="#package.Pkg.Pkg.installed">installed</a></code></li>
<li><code><a title="package.Pkg.Pkg.installed_list" href="#package.Pkg.Pkg.installed_list">installed_list</a></code></li>
<li><code><a title="package.Pkg.Pkg.installed_version" href="#package.Pkg.Pkg.installed_version">installed_version</a></code></li>
<li><code><a title="package.Pkg.Pkg.is_installed" href="#package.Pkg.Pkg.is_installed">is_installed</a></code></li>
<li><code><a title="package.Pkg.Pkg.is_installed_manual" href="#package.Pkg.Pkg.is_installed_manual">is_installed_manual</a></code></li>
<li><code><a title="package.Pkg.Pkg.load_from_index" href="#package.Pkg.Pkg.load_from_index">load_from_index</a></code></li>
<li><code><a title="package.Pkg.Pkg.load_last" href="#package.Pkg.Pkg.load_last">load_last</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>